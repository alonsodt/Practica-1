# -*- coding: utf-8 -*-
"""data_models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZW5G4NpIDXXtxEYXTQjZc02UOtxCol0b
"""

from __future__ import annotations

import math
import random
from dataclasses import dataclass, field
from datetime import date, timedelta
from typing import Dict, List, Optional

from . import utils_stats

@dataclass
class PricePoint:
    """
    Un punto temporal de la serie de precios de un activo.
    """

    date: date
    open: Optional[float]
    high: Optional[float]
    low: Optional[float]
    close: Optional[float]
    volume: Optional[float]


@dataclass
class PriceSeries:
    """
    Serie histórica de precios (o valores) de un activo financiero, ya limpia y estandarizada.

    Este es el OBJETO BÁSICO de la práctica.
    Todas las fuentes (Yahoo, IBKR, FRED...) devolverán SIEMPRE un PriceSeries.
    """

    symbol: str  # Ej: "AAPL", "^GSPC", "DFF"
    source: str  # Ej: "yahoo", "ibkr", "fred"
    asset_type: str  # Ej: "stock", "index", "macro"
    currency: str  # Ej: "USD", "EUR", "%"
    data: List[PricePoint]  # Lista de PricePoint en orden temporal ascendente

    # Campos estadísticos calculados automáticamente
    mean_return: Optional[float] = field(init=False, default=None)
    stdev_return: Optional[float] = field(init=False, default=None)

    def __post_init__(self):
        """
        Al crear el objeto:
        1. Limpiamos y normalizamos la serie.
        2. Calculamos estadísticas básicas (media y desviación típica).
        """
        self.clean()
        self.update_basic_stats()

    # -------------------------
    # Limpieza y preprocesado
    # -------------------------
    def clean(self):
        """
        Limpia/preprocesa la serie:
        - Ordena por fecha ascendente.
        - Quita duplicados de fecha conservando el último válido.
        - Filtra puntos que no tengan 'close'.
        """
        # 1. ordenar por fecha
        self.data.sort(key=lambda p: p.date)

        # 2. quitar duplicados y puntos sin close
        tmp_by_date: Dict[date, PricePoint] = {}
        for pt in self.data:
            if pt.close is not None:
                tmp_by_date[pt.date] = pt
        self.data = [tmp_by_date[d] for d in sorted(tmp_by_date.keys())]

    def _get_close_prices(self) -> List[float]:
        """
        Devuelve la lista de precios de cierre válidos, en orden temporal.
        """
        return [p.close for p in self.data if p.close is not None]

    # -------------------------
    # Estadísticas básicas
    # -------------------------
    def _compute_returns(self) -> List[float]:
        """
        Calcula rendimientos diarios logarítmicos:
        r_t = ln(P_t / P_{t-1})

        Si falta algún precio, ese día se ignora.
        """
        closes = self._get_close_prices()
        return utils_stats.log_returns(closes)

    def update_basic_stats(self):
        """
        Calcula y almacena:
        - mean_return: media de los rendimientos diarios
        - stdev_return: desviación típica de los rendimientos diarios

        Estas métricas sirven luego para Monte Carlo.
        """
        rets = self._compute_returns()
        if len(rets) == 0:
            self.mean_return = None
            self.stdev_return = None
            return

        self.mean_return = utils_stats.mean(rets)
        self.stdev_return = utils_stats.stdev(rets)

    # -------------------------
    # Monte Carlo individual
    # -------------------------
    def monte_carlo(
        self,
        days: int = 30,
        n_paths: int = 1000,
        initial_price: Optional[float] = None,
    ) -> List[List[float]]:
        """
        Simula la evolución futura del precio usando Monte Carlo con un paseo lognormal.

        Supuestos:
        - Los rendimientos diarios siguen una Normal(mu, sigma).
        - mu = mean_return histórica
        - sigma = stdev_return histórica

        Devuelve:
        - Lista de trayectorias.
        Cada trayectoria es una lista de precios [p0, p1, p2, ... p_days]
        """
        # Asegurar que tenemos stats
        if self.mean_return is None or self.stdev_return is None:
            self.update_basic_stats()

        closes = self._get_close_prices()
        if not closes:
            return []

        start_price = initial_price if initial_price is not None else closes[-1]
        mu = self.mean_return if self.mean_return is not None else 0.0
        sigma = self.stdev_return if self.stdev_return is not None else 0.0

        paths: List[List[float]] = []
        for _ in range(n_paths):
            path = [start_price]
            for _d in range(days):
                z = random.gauss(0, 1)  # ~ N(0,1)
                daily_ret = mu + sigma * z  # rendimiento simulado
                next_price = path[-1] * math.exp(daily_ret)
                path.append(next_price)
            paths.append(path)

        return paths

    # -------------------------
    # Serialización / salida estándar
    # -------------------------
    def to_dict(self) -> Dict:
        """
        Convierte la serie a un dict serializable (por ejemplo para JSON).
        """
        return {
            "symbol": self.symbol,
            "source": self.source,
            "asset_type": self.asset_type,
            "currency": self.currency,
            "mean_return": self.mean_return,
            "stdev_return": self.stdev_return,
            "data": [
                {
                    "date": p.date.isoformat(),
                    "open": p.open,
                    "high": p.high,
                    "low": p.low,
                    "close": p.close,
                    "volume": p.volume,
                }
                for p in self.data
            ],
        }